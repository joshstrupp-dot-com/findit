<!-- //////////////////// HTML SETUP //////////////////// -->
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>Data-Driven Review Sphere</title>
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link
      href="https://fonts.googleapis.com/css2?family=Lexend:wght@100..900&family=Noto+Mono:wght@400&display=swap"
      rel="stylesheet"
    />
    <script type="importmap">
      {
        "imports": {
          "three": "https://cdn.jsdelivr.net/npm/three@0.163.0/build/three.module.js",
          "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.163.0/examples/jsm/"
        }
      }
    </script>

    <!-- //////////////////// STYLES //////////////////// -->
    <style>
      body {
        margin: 0;
        overflow: hidden;
        background: #2b2b2b;
        color: #fff;
        font-family: "Lexend", sans-serif;
      }
      canvas {
        display: block;
      }
      #tooltip {
        position: absolute;
        padding: 10px 10px;
        background: rgba(0, 0, 0, 0.9);
        color: #fff;
        border-radius: 5px;
        pointer-events: none;
        display: none;
        font-size: 12px;
        max-width: 350px;
        word-wrap: break-word;
        text-transform: none;
        font-family: "Noto Mono", monospace;
      }
      #author-search,
      #search-btn,
      #reset-btn,
      #info-btn {
        background-color: rgba(0, 0, 0, 0.9);
        color: white;
        border: none;
        border-radius: 5px;
        padding: 8px 12px;
        margin-right: 8px;
        font-family: "Noto Mono", monospace;
        text-transform: uppercase;
        font-size: 12px;
        letter-spacing: 0.5px;
      }
      #author-search {
        border: 1px solid rgba(255, 255, 255, 0.2);
        min-width: 300px;
        width: 40vw;
        max-width: 600px;
      }
      #author-search::placeholder {
        color: #aaa;
        text-transform: uppercase;
      }
      #search-btn:hover,
      #reset-btn:hover,
      #info-btn:hover {
        background-color: rgba(0, 0, 0, 0.95);
        cursor: pointer;
      }
      #suggestions {
        font-family: "Noto Mono", monospace;
        text-transform: uppercase;
        font-size: 12px;
        letter-spacing: 0.5px;
        background: rgba(0, 0, 0, 0.9);
        border-radius: 5px;
      }
      #label-filters {
        position: absolute;
        bottom: 20px;
        left: 20px;
        background: rgba(0, 0, 0, 0.9);
        padding: 15px;
        border-radius: 5px;
        font-family: "Noto Mono", monospace;
        text-transform: uppercase;
        font-size: 12px;
        letter-spacing: 0.5px;
      }
      #label-filters div {
        margin-bottom: 8px;
        font-weight: 600;
      }
      #label-filters label {
        display: block;
        margin: 4px 0;
        cursor: pointer;
      }
      #label-filters span {
        margin-left: 5px;
        font-family: "Noto Mono", monospace;
      }
      /* Custom checkbox styling */
      .label-checkbox {
        -webkit-appearance: none;
        -moz-appearance: none;
        appearance: none;
        width: 14px;
        height: 14px;
        border: 2px solid #666;
        border-radius: 5px;
        background-color: rgba(0, 0, 0, 0.9);
        cursor: pointer;
        position: relative;
        vertical-align: middle;
        margin-right: 8px;
      }
      .label-checkbox:checked {
        background-color: #333;
      }
      .label-checkbox:checked::after {
        content: "âœ“";
        position: absolute;
        color: #fff;
        font-size: 12px;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
      }
      .label-checkbox:hover {
        border-color: #888;
      }

      /* iOS Style Checkbox */
      .ios-checkbox {
        --checkbox-size: 14px;
        position: relative;
        display: flex;
        align-items: center;
        cursor: pointer;
        user-select: none;
        -webkit-tap-highlight-color: transparent;
        margin-bottom: 8px;
        border-radius: 5px;
      }

      .ios-checkbox input {
        display: none;
      }

      .checkbox-wrapper {
        position: relative;
        width: var(--checkbox-size);
        height: var(--checkbox-size);
        border-radius: 5px;
        transition: transform 0.2s ease;
        display: inline-block;
        vertical-align: middle;
        margin-right: 10px;
      }

      .checkbox-bg {
        position: absolute;
        inset: 0;
        border-radius: 5px;
        border: 2px solid var(--checkbox-border);
        background: rgba(0, 0, 0, 0.9);
        transition: all 0.2s ease;
        width: 100%;
        height: 100%;
      }

      /* Checked State: fill with color, remove border */
      .ios-checkbox input:checked + .checkbox-wrapper .checkbox-bg {
        background: var(--checkbox-color);
        border-color: var(--checkbox-color);
      }

      /* Remove checkmark icon entirely */
      .checkbox-icon {
        display: none !important;
      }

      /* Hover Effects */
      .ios-checkbox:hover .checkbox-wrapper {
        transform: scale(1.05);
      }

      /* Active Animation */
      .ios-checkbox:active .checkbox-wrapper {
        transform: scale(0.95);
      }

      /* Focus Styles */
      .ios-checkbox input:focus + .checkbox-wrapper .checkbox-bg {
        box-shadow: 0 0 0 2px var(--checkbox-bg);
      }

      /* Color Themes */
      .ios-checkbox.very-helpful {
        --checkbox-color: #68ffa9;
        --checkbox-bg: rgba(104, 255, 169, 0.2);
        --checkbox-border: #68ffa9;
      }
      .ios-checkbox.somewhat-helpful {
        --checkbox-color: #ffff68;
        --checkbox-bg: rgba(255, 255, 104, 0.2);
        --checkbox-border: #ffff68;
      }
      .ios-checkbox.somewhat-harmful {
        --checkbox-color: #ffae68;
        --checkbox-bg: rgba(255, 174, 104, 0.2);
        --checkbox-border: #ffae68;
      }
      .ios-checkbox.very-harmful {
        --checkbox-color: #ff68a7;
        --checkbox-bg: rgba(255, 104, 167, 0.2);
        --checkbox-border: #ff68a7;
      }

      @keyframes bounce {
        0%,
        100% {
          transform: scale(1);
        }
        50% {
          transform: scale(1.1);
        }
      }
      .ios-checkbox input:checked + .checkbox-wrapper {
        animation: bounce 0.3s cubic-bezier(0.4, 0, 0.2, 1);
      }

      /* Toggle Button Styles */
      .toggle-cont {
        position: absolute;
        bottom: 20px;
        left: 50%;
        transform: translateX(-50%);
        width: 60px;
        height: 30px;
        border-radius: 9999px;
        z-index: 1;
      }

      /* Loader Styles */
      .loader {
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        display: flex;
        align-items: center;
        z-index: 1000;
        border-radius: 5px;
      }

      .bar {
        display: inline-block;
        width: 3px;
        height: 20px;
        background-color: rgba(255, 255, 255, 0.5);
        border-radius: 10px;
        animation: scale-up4 1s linear infinite;
      }

      .bar:nth-child(2) {
        height: 35px;
        margin: 0 5px;
        animation-delay: 0.25s;
      }

      .bar:nth-child(3) {
        animation-delay: 0.5s;
      }

      @keyframes scale-up4 {
        20% {
          background-color: #ffff;
          transform: scaleY(1.5);
        }

        40% {
          transform: scaleY(1);
        }
      }

      .loading-text {
        position: absolute;
        top: 50px;
        left: 50%;
        transform: translateX(-50%);
        font-family: "Noto Mono", monospace;
        font-size: 10pt;
        opacity: 0.5;
        color: white;
        white-space: nowrap;
      }

      .toggle-cont .toggle-input {
        display: none;
      }

      .toggle-cont .toggle-label {
        cursor: pointer;
        position: relative;
        display: inline-block;
        padding: 4px;
        width: 100%;
        height: 100%;
        background: #272727;
        border-radius: 5px;
        box-sizing: content-box;
        box-shadow: 0px 0px 16px -8px #fefefe;
      }

      .toggle-cont .toggle-label .cont-label-play {
        position: relative;
        width: 30px;
        aspect-ratio: 1 / 1;
        background: #5e5e5e;
        border-radius: 5px;
        transition: all 0.5s cubic-bezier(1, 0, 0, 1);
      }

      .toggle-cont .toggle-input:checked + .toggle-label .cont-label-play {
        background: #f43f5e;
        transform: translateX(30px);
        border-radius: 5px;
      }

      .toggle-cont .toggle-label .label-play {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        display: inline-block;
        width: 16px;
        aspect-ratio: 1 / 1;
        background: #fefefe;
        border-radius: 5px;
        clip-path: polygon(25% 0, 75% 50%, 25% 100%, 25% 51%);
        transition: all 0.5s cubic-bezier(1, 0, 0, 1);
      }

      .toggle-cont .toggle-input:checked + .toggle-label .label-play {
        width: 14px;
        clip-path: polygon(0 0, 100% 0, 100% 100%, 0 100%);
        border-radius: 5px;
      }

      /* Card Navigation */
      @keyframes slideOutLeft {
        0% {
          transform: translateX(0);
          opacity: 1;
        }
        100% {
          transform: translateX(-100%);
          opacity: 0;
        }
      }

      @keyframes slideInRight {
        0% {
          transform: translateX(100%);
          opacity: 0;
        }
        100% {
          transform: translateX(0);
          opacity: 1;
        }
      }

      @keyframes slideOutRight {
        0% {
          transform: translateX(0);
          opacity: 1;
        }
        100% {
          transform: translateX(100%);
          opacity: 0;
        }
      }

      @keyframes slideInLeft {
        0% {
          transform: translateX(-100%);
          opacity: 0;
        }
        100% {
          transform: translateX(0);
          opacity: 1;
        }
      }

      .card-nav-btn:hover {
        transform: scale(1.1);
        background: rgba(0, 0, 0, 0.8);
      }

      .card-nav-btn:disabled {
        opacity: 0.3;
        cursor: not-allowed;
      }

      .card-nav-btn {
        opacity: 0.7;
      }

      .card-nav-btn:hover {
        opacity: 1;
      }

      #recommendation-cards .book-card {
        cursor: pointer;
      }
    </style>
    <script src="https://d3js.org/d3.v7.min.js"></script>
  </head>
  <body>
    <div
      id="controls"
      style="position: absolute; top: 25px; left: 25px; z-index: 1"
    >
      <input
        id="author-search"
        type="text"
        placeholder="Enter your concern or question"
      />
      <button id="search-btn">Search</button>
      <button id="reset-btn">Reset</button>
    </div>
    <div
      id="logo-container"
      style="position: absolute; top: 25px; right: 25px; z-index: 1"
    >
      <img src="logo.svg" alt="Logo" style="height: 100px; width: auto" />
    </div>
    <div class="toggle-cont">
      <input
        type="checkbox"
        id="rotation-toggle"
        class="toggle-input"
        checked
      />
      <label for="rotation-toggle" class="toggle-label">
        <div class="cont-label-play">
          <div class="label-play"></div>
        </div>
      </label>
    </div>
    <div
      id="info-container"
      style="position: absolute; bottom: 20px; right: 20px; z-index: 1"
    >
      <button id="info-btn">What is this?</button>
      <div
        id="info-dropdown"
        style="
          position: fixed;
          top: 50%;
          left: 50%;
          transform: translate(-50%, -50%);
          background: rgba(0, 0, 0, 0.9);
          color: #fff;
          border-radius: 5px;
          padding: 25px;
          max-width: 600px;
          width: 90%;
          display: none;
          font-family: 'Noto Mono', monospace;
          font-size: 12px;
          line-height: 1.5;
          box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
          z-index: 1000;
        "
      >
        <button
          class="close-btn"
          style="
            color: #ffffff;
            background: none;
            border: none;
            font-size: 24px;
            position: absolute;
            top: 10px;
            right: 10px;
            cursor: pointer;
            /* text-shadow: 0 0 1px #999; */
          "
        >
          x
        </button>
        <p>
          Self-help books promise to change your life or improve it through
          various means - whether exercise, philosophy, or sheer willpower.
          While star ratings tell us if readers liked a book, they don't reveal
          whether the book actually helped or potentially harmed readers.
        </p>
        <p>
          This project uses machine learning (zero-shot classification) to
          analyze over 300,000 reviews across 10,000 self-help books,
          categorizing them based on whether they were truly helpful or
          potentially harmful to readers.
        </p>
        <p>
          The results are visualized here as an interactive 3D sphere of data
          points. Each point represents a review, with colors indicating the
          sentiment (from very helpful to very harmful) and size showing the
          review length. Reviews are clustered by book and author, revealing
          patterns in how different works impact readers.
        </p>
        <p>
          Use the search bar to enter your own natural language query, toggle
          the checkboxes to filter by review sentiment, and hover over any point
          to read the full review text and book details.
        </p>
        <p>
          Created by me,
          <a
            href="https://joshstrupp.com"
            style="color: #68ffa9; text-decoration: none"
            >Josh</a
          >.
        </p>
      </div>
    </div>
    <div id="label-filters">
      <div>Filter by Label:</div>
      <label class="ios-checkbox very-helpful">
        <input
          type="checkbox"
          class="label-checkbox"
          value="Very Helpful"
          checked
        />
        <div class="checkbox-wrapper">
          <div class="checkbox-bg"></div>
        </div>
        <span style="color: rgba(104, 255, 169, 0.9)">Very Helpful</span>
      </label>
      <label class="ios-checkbox somewhat-helpful">
        <input
          type="checkbox"
          class="label-checkbox"
          value="Somewhat Helpful"
          checked
        />
        <div class="checkbox-wrapper">
          <div class="checkbox-bg"></div>
        </div>
        <span style="color: rgba(255, 255, 104, 0.9)">Somewhat Helpful</span>
      </label>
      <label class="ios-checkbox somewhat-harmful">
        <input
          type="checkbox"
          class="label-checkbox"
          value="Somewhat Harmful"
          checked
        />
        <div class="checkbox-wrapper">
          <div class="checkbox-bg"></div>
        </div>
        <span style="color: rgba(255, 174, 104, 0.9)">Somewhat Harmful</span>
      </label>
      <label class="ios-checkbox very-harmful">
        <input
          type="checkbox"
          class="label-checkbox"
          value="Very Harmful"
          checked
        />
        <div class="checkbox-wrapper">
          <div class="checkbox-bg"></div>
        </div>
        <span style="color: rgba(255, 160, 160, 0.9)">Very Harmful</span>
      </label>
    </div>
    <canvas id="three-canvas"></canvas>
    <div id="tooltip"></div>
    <div class="loader">
      <div class="bar"></div>
      <div class="bar"></div>
      <div class="bar"></div>
      <div class="loading-text">Loading Reviews...</div>
    </div>

    <!-- Book Recommendation Cards -->
    <div
      id="recommendation-cards"
      style="
        position: absolute;
        top: 100px;
        left: 25px;
        width: 400px;
        max-height: 80vh;
        overflow-y: auto;
        overflow-x: hidden;
        z-index: 100;
        display: none;
        padding-top: 10px;
        padding-right: 15px;
        padding-left: 15px;
        box-sizing: border-box;
      "
    >
      <div
        style="
          font-family: 'Noto Mono', monospace;
          font-size: 12px;
          text-transform: uppercase;
          margin-bottom: 15px;
          text-align: center;
          letter-spacing: 1px;
          font-weight: 600;
        "
      >
        Recommended Books
      </div>
      <button
        id="close-cards-btn"
        style="
          position: absolute;
          top: 5px;
          right: 15px;
          background: none;
          border: none;
          color: #fff;
          font-size: 20px;
          cursor: pointer;
          z-index: 101;
          opacity: 0.7;
          transition: opacity 0.2s;
        "
      >
        Ã—
      </button>

      <!-- Card Stack Container -->
      <div
        id="card-stack"
        style="
          position: relative;
          height: 320px;
          width: 100%;
          margin-bottom: 60px;
        "
      >
        <!-- Navigation Buttons Container -->
        <div
          style="
            position: absolute;
            bottom: 50px;
            left: 0;
            right: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 20px;
          "
        >
          <!-- Previous Button -->
          <button
            id="prev-card"
            class="card-nav-btn"
            style="
              display: block;
              background: rgba(0, 0, 0, 0.6);
              border: 2px solid rgba(255, 255, 255, 0.7);
              border-radius: 50%;
              width: 40px;
              height: 40px;
              color: rgba(255, 255, 255, 0.9);
              text-align: center;
              line-height: 35px;
              cursor: pointer;
              font-size: 20px;
              z-index: 102;
              transition: all 0.2s ease;
            "
          >
            &#10094;
          </button>

          <!-- Next Button -->
          <button
            id="next-card"
            class="card-nav-btn"
            style="
              display: block;
              background: rgba(0, 0, 0, 0.6);
              border: 2px solid rgba(255, 255, 255, 0.7);
              border-radius: 50%;
              width: 40px;
              height: 40px;
              color: rgba(255, 255, 255, 0.9);
              text-align: center;
              line-height: 35px;
              cursor: pointer;
              font-size: 20px;
              z-index: 102;
              transition: all 0.2s ease;
            "
          >
            &#10095;
          </button>
        </div>

        <!-- Card list container -->
        <ul
          id="card-container"
          style="
            position: relative;
            list-style: none;
            padding: 0;
            margin: 0;
            width: 100%;
            height: 100%;
          "
        ></ul>
      </div>
    </div>

    <!-- //////////////////// MAIN VISUALIZATION CODE //////////////////// -->
    <script type="module">
      import * as THREE from "three";
      import { OrbitControls } from "three/addons/controls/OrbitControls.js";

      //////////////////// UTILITY FUNCTIONS ////////////////////
      // Helper: string -> [0,1] hash
      function hashTo01(str) {
        let h = 0;
        for (let i = 0; i < str.length; i++) {
          h = (h << 5) - h + str.charCodeAt(i);
          h |= 0;
        }
        return (h >>> 0) / 0xffffffff;
      }

      // Animate the camera smoothly to a new cluster center.
      function animateCameraTo(targetCenter, targetDistance, duration) {
        const startPos = camera.position.clone();
        const startTarget = controls.target.clone();
        const desiredPos = new THREE.Vector3(
          targetCenter.x + targetDistance,
          targetCenter.y + targetDistance * 0.5,
          targetCenter.z + targetDistance
        );
        const startTime = performance.now();
        function update() {
          const t = Math.min((performance.now() - startTime) / duration, 1);
          camera.position.lerpVectors(startPos, desiredPos, t);
          controls.target.lerpVectors(startTarget, targetCenter, t);
          controls.update();
          if (t < 1) {
            requestAnimationFrame(update);
          }
        }
        update();
      }

      // Create a recommendation card
      function createRecommendationCard(book, index, total) {
        const cardLi = document.createElement("li");
        cardLi.className = "book-card";
        cardLi.style.cssText = `
            background: rgba(0, 0, 0, 0.9);
            color: #fff;
            border-radius: 10px;
            padding: 15px;
            margin-bottom: 15px;
            font-family: 'Lexend', sans-serif;
            width: 100%;
            box-sizing: border-box;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(255, 255, 255, 0.3);
            position: absolute;
            transition: all 300ms ease-in-out;
            list-style: none;
            height: auto;
            left: 0;
            right: 0;
            margin: 0 auto;
            opacity: ${index === 0 ? 1 : 0.6 - index * 0.1};
            transform: translateY(${index * 12}px) scale(${1 - index * 0.05});
            z-index: ${total - index};
            ${index > 0 ? "pointer-events: none;" : ""}
          `;

        // Title
        const titleDiv = document.createElement("div");
        titleDiv.style.cssText = `
            font-size: 16px;
            font-weight: 700;
            margin-bottom: 5px;
            text-transform: uppercase;
          `;
        titleDiv.textContent = book.name;
        cardLi.appendChild(titleDiv);

        // Author
        const authorDiv = document.createElement("div");
        authorDiv.style.cssText = `
            font-size: 13px;
            margin-bottom: 6px;
            opacity: 0.7;
          `;
        authorDiv.textContent = book.author;
        cardLi.appendChild(authorDiv);

        // Rating and Price
        const ratingDiv = document.createElement("div");
        ratingDiv.style.cssText = `
            font-size: 12px;
            margin-bottom: 20px;
            display: flex;
            align-items: center;
          `;
        ratingDiv.innerHTML = `â­ï¸: ${book.rating || "N/A"} ${
          book.price ? ` â€¢ ${book.price}` : ""
        }`;
        cardLi.appendChild(ratingDiv);

        // Helpful Bar
        if (book.helpfulRatio) {
          const helpfulLabel = document.createElement("div");
          helpfulLabel.style.cssText = `
              font-size: 11px;
              margin-bottom: 6px;
              opacity: 0.8;
              font-family: 'Noto Mono', monospace;
            `;
          helpfulLabel.textContent = "READER HELPFULNESS";
          cardLi.appendChild(helpfulLabel);

          const barContainer = document.createElement("div");
          barContainer.style.cssText = `
              width: 100%;
              height: 8px;
              background: rgba(255, 255, 255, 0.1);
              border-radius: 4px;
              margin-top: 5px;
              margin-bottom: 5px;
            `;

          const bar = document.createElement("div");
          const helpfulColor = "#68FFA9"; // Green for helpful
          bar.style.cssText = `
              width: ${book.helpfulRatio * 100}%;
              height: 100%;
              background: ${helpfulColor};
              border-radius: 4px;
              transition: width 0.5s ease;
            `;
          barContainer.appendChild(bar);

          const barLabel = document.createElement("div");
          barLabel.style.cssText = `
              font-size: 12px;
              text-align: right;
              margin-top: 4px;
              opacity: 0.9;
              font-weight: 500;
              font-family: 'Noto Mono', monospace;
            `;
          barLabel.textContent = `${Math.round(book.helpfulRatio * 100)}%`;

          cardLi.appendChild(barContainer);
          cardLi.appendChild(barLabel);
        }

        // Card Counter (x of y)
        const counterDiv = document.createElement("div");
        counterDiv.style.cssText = `
            position: absolute;
            bottom: 10px;
            left: 15px;
            font-size: 10px;
            opacity: 0.5;
            font-family: 'Noto Mono', monospace;
          `;
        counterDiv.textContent = `${index + 1} of ${total}`;
        cardLi.appendChild(counterDiv);

        return cardLi;
      }

      // Parse Gradio API response and extract book recommendations
      function parseAPIResponse(responseText) {
        // Check if responseText is an array and get the first item if it is
        if (Array.isArray(responseText)) {
          responseText = responseText[0];
        }

        // Ensure responseText is a string
        if (typeof responseText !== "string") {
          console.error("Unexpected response format:", responseText);
          return [];
        }

        // Extract book information using regex
        const books = [];

        // Book name regex
        const bookRegex = /ðŸ“š\s*(.+)/g;
        // Author regex
        const authorRegex = /ðŸ‘¤\s*Author:\s*(.+)/g;
        // Rating regex
        const ratingRegex = /â­\s*Rating:\s*(.+)/g;
        // Price regex
        const priceRegex = /ðŸ’°\s*Price:\s*(.+)/g;
        // Helpful Ratio regex
        const ratioRegex = /ðŸ“Š\s*Helpful Ratio:\s*(.+)/g;
        // Helpful Reviews section regex
        const helpfulReviewsStartRegex = /âœ…\s*Helpful Reviews:/;
        const criticalReviewsStartRegex = /âš ï¸\s*Critical Reviews:/;

        // Get all matches for book names
        let bookMatches = [];
        let match;
        while ((match = bookRegex.exec(responseText)) !== null) {
          bookMatches.push({ name: match[1].trim(), index: match.index });
        }

        // For each book, find the associated information
        bookMatches.forEach((bookMatch, i) => {
          const book = { name: bookMatch.name };

          // Get text segment for this book (from this book name to next book name or end)
          const nextBookIndex =
            i < bookMatches.length - 1
              ? bookMatches[i + 1].index
              : responseText.length;
          const bookSegment = responseText.substring(
            bookMatch.index,
            nextBookIndex
          );

          // Extract author
          const authorMatch = authorRegex.exec(bookSegment);
          if (authorMatch) book.author = authorMatch[1].trim();

          // Extract rating
          const ratingMatch = ratingRegex.exec(bookSegment);
          if (ratingMatch) book.rating = parseFloat(ratingMatch[1].trim());

          // Extract price
          const priceMatch = priceRegex.exec(bookSegment);
          if (priceMatch) book.price = priceMatch[1].trim();

          // Extract helpful ratio
          const ratioMatch = ratioRegex.exec(bookSegment);
          if (ratioMatch) book.helpfulRatio = parseFloat(ratioMatch[1].trim());

          // Extract helpful reviews
          let helpfulReviews = [];
          const helpfulReviewsStartMatch =
            helpfulReviewsStartRegex.exec(bookSegment);
          const criticalReviewsStartMatch =
            criticalReviewsStartRegex.exec(bookSegment);

          if (helpfulReviewsStartMatch) {
            const helpfulStartIndex =
              helpfulReviewsStartMatch.index +
              helpfulReviewsStartMatch[0].length;
            const helpfulEndIndex = criticalReviewsStartMatch
              ? criticalReviewsStartMatch.index
              : bookSegment.length;
            const helpfulSection = bookSegment
              .substring(helpfulStartIndex, helpfulEndIndex)
              .trim();

            // Split by bullet points
            const helpfulBullets = helpfulSection
              .split("â€¢")
              .filter(Boolean)
              .map((r) => r.trim());
            helpfulReviews = helpfulBullets;
          }

          // Use the first helpful review as the main review
          if (helpfulReviews.length > 0) {
            book.review = helpfulReviews[0];
          }

          books.push(book);
        });

        return books;
      }

      // Function to display recommendation cards as a stack
      function displayRecommendationCards(books) {
        // Clear the card container
        const cardContainer = document.getElementById("card-container");
        cardContainer.innerHTML = "";

        // Get navigation buttons
        const prevBtn = document.getElementById("prev-card");
        const nextBtn = document.getElementById("next-card");

        // Create and append cards for each book
        books.forEach((book, index) => {
          const card = createRecommendationCard(book, index, books.length);
          // Add click listener to reposition the camera on the cluster for this book
          card.addEventListener("click", () => {
            // Find the first review for this book in allData to get correct author_clean
            const bookName = book.name.trim().toLowerCase();
            const matchingReview = allData.find(
              (d) => d.name.trim().toLowerCase() === bookName
            );

            if (matchingReview) {
              const prismWidth = 55;
              const prismHeight = 80;
              const prismDepth = 10;

              // Use the matching review's data to calculate the cluster center
              const clusterCenter = new THREE.Vector3(
                (hashTo01(matchingReview.name) - 0.5) * prismWidth,
                (hashTo01(matchingReview.author_clean) - 0.5) * prismHeight,
                (hashTo01(matchingReview.name + matchingReview.author_clean) -
                  0.5) *
                  prismDepth
              );

              const distance = 30;
              animateCameraTo(clusterCenter, distance, 1000);
            } else {
              console.warn(
                `Could not find matching review for book: ${book.name}`
              );
            }
          });
          cardContainer.appendChild(card);
        });

        // Show the recommendations panel
        document.getElementById("recommendation-cards").style.display = "block";

        // Add responsiveness for mobile
        adjustCardPositionForScreenSize();

        // Track current active card
        let currentCardIndex = 0;

        // Show/hide navigation buttons based on card count
        if (books.length <= 1) {
          prevBtn.style.display = "none";
          nextBtn.style.display = "none";
        } else {
          prevBtn.style.display = "block";
          nextBtn.style.display = "block";

          // Add click handlers for navigation
          prevBtn.onclick = function () {
            if (currentCardIndex > 0) {
              const cards = cardContainer.querySelectorAll(".book-card");

              // Hide current card with animation
              const currentCard = cards[currentCardIndex];
              currentCard.style.animation = "slideOutRight 300ms forwards";

              // Show previous card
              currentCardIndex--;
              const prevCard = cards[currentCardIndex];

              // Reset all other cards
              cards.forEach((card, idx) => {
                if (idx !== currentCardIndex) {
                  card.style.opacity =
                    0.6 - Math.abs(currentCardIndex - idx) * 0.1;
                  card.style.transform = `translateY(${
                    Math.abs(currentCardIndex - idx) * 12
                  }px) scale(${1 - Math.abs(currentCardIndex - idx) * 0.05})`;
                  card.style.zIndex =
                    books.length - Math.abs(currentCardIndex - idx);
                  card.style.pointerEvents = "none";
                  card.style.animation = "";
                }
              });

              // Style active card
              prevCard.style.opacity = 1;
              prevCard.style.transform = "translateY(0) scale(1)";
              prevCard.style.zIndex = books.length;
              prevCard.style.pointerEvents = "auto";
              prevCard.style.animation = "slideInLeft 300ms forwards";

              // Update button states
              nextBtn.disabled = false;
              prevBtn.disabled = currentCardIndex === 0;
            }
          };

          nextBtn.onclick = function () {
            if (currentCardIndex < books.length - 1) {
              const cards = cardContainer.querySelectorAll(".book-card");

              // Hide current card with animation
              const currentCard = cards[currentCardIndex];
              currentCard.style.animation = "slideOutLeft 300ms forwards";

              // Show next card
              currentCardIndex++;
              const nextCard = cards[currentCardIndex];

              // Reset all other cards
              cards.forEach((card, idx) => {
                if (idx !== currentCardIndex) {
                  card.style.opacity =
                    0.6 - Math.abs(currentCardIndex - idx) * 0.1;
                  card.style.transform = `translateY(${
                    Math.abs(currentCardIndex - idx) * 12
                  }px) scale(${1 - Math.abs(currentCardIndex - idx) * 0.05})`;
                  card.style.zIndex =
                    books.length - Math.abs(currentCardIndex - idx);
                  card.style.pointerEvents = "none";
                  card.style.animation = "";
                }
              });

              // Style active card
              nextCard.style.opacity = 1;
              nextCard.style.transform = "translateY(0) scale(1)";
              nextCard.style.zIndex = books.length;
              nextCard.style.pointerEvents = "auto";
              nextCard.style.animation = "slideInRight 300ms forwards";

              // Update button states
              prevBtn.disabled = false;
              nextBtn.disabled = currentCardIndex === books.length - 1;
            }
          };

          // Initialize button states
          prevBtn.disabled = currentCardIndex === 0;
          nextBtn.disabled = books.length <= 1;
        }
      }

      function adjustCardPositionForScreenSize() {
        const cards = document.getElementById("recommendation-cards");

        if (window.innerWidth < 768) {
          // Mobile layout - position at bottom
          cards.style.top = "auto";
          cards.style.bottom = "20px";
          cards.style.left = "50%";
          cards.style.transform = "translateX(-50%)";
          cards.style.width = "90%";
          cards.style.maxWidth = "380px";
          cards.style.maxHeight = "70vh";
          cards.style.paddingLeft = "15px";
          cards.style.paddingRight = "15px";
          cards.style.boxSizing = "border-box";
        } else {
          // Desktop layout - position at top left
          cards.style.top = "100px";
          cards.style.bottom = "auto";
          cards.style.left = "25px";
          cards.style.transform = "none";
          cards.style.width = "400px";
          cards.style.maxHeight = "80vh";
          cards.style.paddingLeft = "15px";
          cards.style.paddingRight = "15px";
          cards.style.boxSizing = "border-box";
        }
      }

      //////////////////// CONSTANTS & SETUP ////////////////////
      // Map labels to colors
      const labelColor = {
        "Very Harmful": "#FF68A7",
        "Somewhat Harmful": "#FFAE68",
        "Somewhat Helpful": "#FFFF68",
        "Very Helpful": "#68FFA9",
      };

      const canvas = document.getElementById("three-canvas");
      const renderer = new THREE.WebGLRenderer({ canvas, antialias: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.setPixelRatio(window.devicePixelRatio);

      const scene = new THREE.Scene();
      const camera = new THREE.PerspectiveCamera(
        60,
        window.innerWidth / window.innerHeight,
        0.1,
        1000
      );
      camera.position.set(
        93.8249062976176,
        -14.513052356383655,
        68.44704045303914
      );

      const controls = new OrbitControls(camera, renderer.domElement);
      controls.enableDamping = true;

      const raycaster = new THREE.Raycaster();
      const pointer = new THREE.Vector2();
      const tooltip = document.getElementById("tooltip");
      var allData = [];
      let activeBookNames = null; // Global: if set, these points are active
      console.log("Initial state: activeBookNames =", activeBookNames);

      //////////////////// DATA LOADING & VISUALIZATION ////////////////////
      // Load CSV and build point cloud
      const loader = document.querySelector(".loader");
      d3.csv(
        "https://findit-selfhelp.s3.us-east-1.amazonaws.com/zeroshot_analysis_results.csv"
      ).then((raw) => {
        loader.style.display = "none";
        allData = raw.filter((d) => d.predicted_label);
        let data = allData;

        // Precompute size scale using full dataset
        const lengths = allData.map((d) => d.review_text.length);
        const sizeScale = d3
          .scaleLinear()
          .domain(d3.extent(lengths))
          .range([4, 20]);

        // Create geometry and material once
        const geom = new THREE.BufferGeometry();
        const material = new THREE.ShaderMaterial({
          vertexColors: true,
          transparent: true,
          depthTest: true,
          vertexShader: `
            attribute float size;
            attribute float opacity;
            varying vec3 vColor;
            varying float vOpacity;
            void main() {
              vColor = color;
              vOpacity = opacity;
              vec4 mvPos = modelViewMatrix * vec4(position, 1.0);
              gl_PointSize = size * (200.0 / -mvPos.z);
              gl_Position = projectionMatrix * mvPos;
            }
          `,
          fragmentShader: `
            varying vec3 vColor;
            varying float vOpacity;
            void main() {
              float d = distance(gl_PointCoord, vec2(0.5));
              if (d > 0.5) discard;
              // Stroke: scale alpha to ~0.1667 of inner opacity
              if (d > 0.45) {
                gl_FragColor = vec4(0.0, 0.0, 0.0, vOpacity * 0.1667);
              } else {
                gl_FragColor = vec4(vColor, vOpacity);
              }
            }
          `,
        });
        const points = new THREE.Points(geom, material);
        scene.add(points);

        // Function to update point positions, colors, sizes
        function updatePoints() {
          const positions = [];
          const colors = [];
          const sizes = [];
          const opacities = [];

          // If a search query is active, filter based on the active book names (case-insensitive)
          const baseData =
            activeBookNames !== null
              ? allData.filter((d) =>
                  activeBookNames.some(
                    (bookName) =>
                      d.name.trim().toLowerCase() ===
                      bookName.trim().toLowerCase()
                  )
                )
              : data;

          console.log(
            "updatePoints: activeBookNames =",
            activeBookNames,
            "baseData count =",
            baseData.length
          );

          // Use different dimensions when not in search (as before) using baseData
          const isFiltered =
            activeBookNames !== null ? false : data.length < allData.length;
          const prismWidth = isFiltered ? 20 : 55;
          const prismHeight = isFiltered ? 30 : 80;
          const prismDepth = isFiltered ? 5 : 10;

          // Group data by book/author from baseData
          const groupMap = {};
          baseData.forEach((d) => {
            const key = d.name + "||" + d.author_clean;
            if (!groupMap[key]) groupMap[key] = [];
            groupMap[key].push(d);
          });

          // For each group, assign cluster offset and push vertices
          Object.entries(groupMap).forEach(([key, group]) => {
            // Compute base cluster position
            const baseX = (hashTo01(group[0].name) - 0.5) * prismWidth;
            const baseY = (hashTo01(group[0].author_clean) - 0.5) * prismHeight;
            const baseZ =
              (hashTo01(group[0].name + group[0].author_clean) - 0.5) *
              prismDepth;

            const clusterRadius =
              activeBookNames !== null ? 1.5 : isFiltered ? 0.8 : 1.5;
            group.forEach((d, i) => {
              const angle = (2 * Math.PI * i) / group.length;
              const offsetR =
                clusterRadius * (0.5 + 0.5 * hashTo01(d.review_text));
              const dx = Math.cos(angle) * offsetR;
              const dy = Math.sin(angle) * offsetR;
              const dz = (hashTo01(d.review_text + "z") - 0.5) * clusterRadius;
              positions.push(baseX + dx, baseY + dy, baseZ + dz);

              const hex = labelColor[d.predicted_label] || "#888";
              const col = new THREE.Color(hex);
              colors.push(col.r, col.g, col.b);
              sizes.push(sizeScale(d.review_text.length));

              // All points in active book search mode get full opacity since we've filtered
              if (activeBookNames !== null) {
                opacities.push(0.8); // Higher opacity for search results
                sizes[sizes.length - 1] *= 1.5; // Make search result points larger
              } else {
                opacities.push(0.6);
              }
            });
          });

          geom.setAttribute(
            "position",
            new THREE.Float32BufferAttribute(positions, 3)
          );
          geom.setAttribute(
            "color",
            new THREE.Float32BufferAttribute(colors, 3)
          );
          geom.setAttribute("size", new THREE.Float32BufferAttribute(sizes, 1));
          geom.setAttribute(
            "opacity",
            new THREE.Float32BufferAttribute(opacities, 1)
          );

          // Create specialized material in search mode
          if (activeBookNames !== null) {
            scene.remove(points); // Remove the existing points

            // Use a material that renders on top (no depth test)
            const searchModeMaterial = new THREE.ShaderMaterial({
              vertexColors: true,
              transparent: true,
              depthTest: false, // Render on top
              depthWrite: false, // Don't write to depth buffer
              vertexShader: material.vertexShader,
              fragmentShader: material.fragmentShader,
            });

            // Create points with the filtered data
            const searchModePoints = new THREE.Points(geom, searchModeMaterial);
            scene.add(searchModePoints);

            // Save reference for raycasting and animation
            points.userData = {
              activePoints: searchModePoints,
              isSearchMode: true,
            };
            scene.add(points);
            points.visible = false; // Hide the original points
          } else {
            // If we're in normal mode, remove any search mode points and show the main points
            scene.traverse((object) => {
              if (object instanceof THREE.Points && object !== points) {
                scene.remove(object);
              }
            });

            points.visible = true;
            points.userData = { isSearchMode: false };
          }

          // Reposition camera if not in search mode
          if (activeBookNames === null && positions.length > 0) {
            const center = new THREE.Vector3();
            for (let i = 0; i < positions.length; i += 3) {
              center.x += positions[i];
              center.y += positions[i + 1];
              center.z += positions[i + 2];
            }
            center.divideScalar(positions.length / 3);

            const distance = Math.max(
              50,
              Math.min(70, 60 + positions.length / 100)
            );
            camera.position.set(
              center.x + distance,
              center.y + distance * 0.5,
              center.z + distance
            );
            camera.lookAt(center);
            controls.target.copy(center);
            controls.update();
          }
        }

        // Initial render
        updatePoints();

        // Search and reset handlers
        const searchInput = document.getElementById("author-search");
        const labelCheckboxes = document.querySelectorAll(".label-checkbox");
        const recommendationCards = document.getElementById(
          "recommendation-cards"
        );
        const cardContainer = document.getElementById("card-container");

        // Function to get active label filters
        function getActiveLabels() {
          return Array.from(labelCheckboxes)
            .filter((checkbox) => checkbox.checked)
            .map((checkbox) => checkbox.value);
        }

        // Function to apply all filters
        function applyFilters() {
          const query = searchInput.value.trim().toLowerCase();
          const activeLabels = getActiveLabels();

          data = allData.filter((d) => {
            const matchesLabel = activeLabels.includes(d.predicted_label);
            return matchesLabel;
          });

          updatePoints();
        }

        // Add close button functionality for recommendation cards
        const closeCardsBtn = document.getElementById("close-cards-btn");

        closeCardsBtn.addEventListener("mouseenter", () => {
          closeCardsBtn.style.opacity = "1";
        });

        closeCardsBtn.addEventListener("mouseleave", () => {
          closeCardsBtn.style.opacity = "0.7";
        });

        closeCardsBtn.addEventListener("click", () => {
          document.getElementById("recommendation-cards").style.display =
            "none";
        });

        // Add window resize listener to adjust card position
        window.addEventListener("resize", adjustCardPositionForScreenSize);

        document
          .getElementById("search-btn")
          .addEventListener("click", async () => {
            const query = document.getElementById("author-search").value.trim();
            if (!query) {
              console.log("Empty query, skipping API call");
              return;
            }
            try {
              const { Client } = await import(
                "https://cdn.jsdelivr.net/npm/@gradio/client?module"
              );
              const client = await Client.connect(
                "joshstrupp/Self-Help-Book-Recommendation-Engine"
              );
              const result = await client.predict("/predict", {
                concern: query,
                num_books: 3,
                num_reviews: 3,
              });
              console.log("API result:", result.data);

              const books = parseAPIResponse(result.data);
              console.log("Parsed book recommendations:", books);

              if (books && books.length > 0) {
                displayRecommendationCards(books);
                const bookNames = books.map((book) => book.name);
                activeBookNames = bookNames;
                console.log("Active book names set to:", activeBookNames);
                updatePoints();
              } else {
                console.log("No book recommendations found in API response");
                // existing logic for no results card
                const noResultsCard = document.createElement("div");
                noResultsCard.style.cssText = `background: rgba(0, 0, 0, 0.9); color: #fff; border-radius: 10px; padding: 15px; margin-bottom: 15px; font-family: 'Lexend', sans-serif; width: 100%; text-align: center;`;
                noResultsCard.innerHTML = `<div style="font-size: 16px; margin-bottom: 10px;">No books found for your query</div><div style="font-size: 14px; opacity: 0.7;">Try a different search term</div>`;
                document.getElementById("card-container").innerHTML = "";
                document
                  .getElementById("card-container")
                  .appendChild(noResultsCard);
                document.getElementById("recommendation-cards").style.display =
                  "block";
              }
            } catch (error) {
              console.error("Error calling API:", error);
              const errorCard = document.createElement("div");
              errorCard.style.cssText = `background: rgba(0, 0, 0, 0.9); color: #fff; border-radius: 10px; padding: 15px; margin-bottom: 15px; font-family: 'Lexend', sans-serif; width: 100%; text-align: center;`;
              errorCard.innerHTML = `<div style="font-size: 16px; margin-bottom: 10px;">Error finding recommendations</div><div style="font-size: 14px; opacity: 0.7;">Please try again later</div>`;
              document.getElementById("card-container").innerHTML = "";
              document.getElementById("card-container").appendChild(errorCard);
              document.getElementById("recommendation-cards").style.display =
                "block";
            }
          });

        document.getElementById("reset-btn").addEventListener("click", () => {
          activeBookNames = null;
          data = allData;
          console.log("Reset: activeBookNames cleared, showing full data.");
          document.getElementById("author-search").value = "";
          document
            .querySelectorAll(".label-checkbox")
            .forEach((checkbox) => (checkbox.checked = true));
          document.getElementById("recommendation-cards").style.display =
            "none";
          updatePoints();
        });

        // Add event listeners for label checkboxes
        labelCheckboxes.forEach((checkbox) => {
          checkbox.addEventListener("change", applyFilters);
        });

        // Hover handling
        function onPointerMove(event) {
          pointer.x = (event.clientX / window.innerWidth) * 2 - 1;
          pointer.y = -(event.clientY / window.innerHeight) * 2 + 1;

          raycaster.setFromCamera(pointer, camera);

          // Handle raycasting for both regular mode and search mode
          let hits = [];
          if (points.userData && points.userData.isSearchMode) {
            // In search mode, use the active points for raycasting
            const activeHits = raycaster.intersectObject(
              points.userData.activePoints
            );
            if (activeHits.length > 0) {
              hits = activeHits;
            }
          } else {
            hits = raycaster.intersectObject(points);
          }

          if (hits.length > 0) {
            let hit = hits[0]; // Use the first hit

            const baseDataForHover =
              activeBookNames !== null
                ? allData.filter((d) =>
                    activeBookNames.some(
                      (bookName) =>
                        d.name.trim().toLowerCase() ===
                        bookName.trim().toLowerCase()
                    )
                  )
                : data;

            // Get the review for this hit
            const index = hit.index;
            if (index >= baseDataForHover.length) {
              console.warn(
                "Hit index out of bounds:",
                index,
                "baseDataForHover length:",
                baseDataForHover.length
              );
              tooltip.style.display = "none";
              return;
            }

            const d = baseDataForHover[index];

            tooltip.style.display = "block";
            tooltip.style.left = event.clientX + 8 + "px";
            tooltip.style.top = event.clientY + 8 + "px";
            tooltip.innerHTML = `
              <div style="font-size: 16px; text-transform: uppercase; margin-bottom: 8px;"><strong>${
                d.name
              }</strong></div>
              <div style="opacity: 0.5; margin: 8px 0; font-family: 'Noto Mono', monospace;">${
                d.author_clean
              }</div>
              <div style="margin-bottom: 8px;"><em style="color: ${
                labelColor[d.predicted_label]
              }; font-family: 'Noto Mono', monospace;">${
              d.predicted_label
            }</em></div>
              <div>${
                d.review_text.length > 500
                  ? d.review_text.substring(0, 500) + "..."
                  : d.review_text
              }</div>
            `;
          } else {
            tooltip.style.display = "none";
          }
        }

        // Remove the previous event listener setup (if any) and add the updated one:
        window.removeEventListener("pointermove", onPointerMove);
        window.addEventListener("pointermove", onPointerMove);

        //////////////////// ANIMATION LOOP ////////////////////
        // render loop
        function animate() {
          requestAnimationFrame(animate);
          const rotationToggle = document.getElementById("rotation-toggle");
          if (rotationToggle.checked) {
            // Rotate the points
            if (points.userData && points.userData.isSearchMode) {
              if (points.userData.activePoints) {
                points.userData.activePoints.rotation.y += 0.001;
              }
            } else {
              points.rotation.y += 0.001;
            }
          }
          controls.update();

          renderer.render(scene, camera);
        }
        animate();

        // Add info popup toggle
        const infoBtn = document.getElementById("info-btn");
        const infoPopup = document.getElementById("info-dropdown");
        const closeBtn = infoPopup.querySelector(".close-btn");

        infoBtn.addEventListener("click", () => {
          infoPopup.style.display = "block";
        });

        closeBtn.addEventListener("click", () => {
          infoPopup.style.display = "none";
        });

        // Close popup when clicking outside
        document.addEventListener("click", (e) => {
          if (e.target === infoPopup) {
            infoPopup.style.display = "none";
          }
        });
      });

      //////////////////// WINDOW RESIZE HANDLER ////////////////////
      // handle resize
      window.addEventListener("resize", () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      });
    </script>
  </body>
</html>
